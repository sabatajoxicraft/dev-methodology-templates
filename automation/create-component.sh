#!/bin/bash

# üéØ Create Component/Module Script
# Creates a new module with proper structure and documentation
# TECH-STACK AGNOSTIC: Works with any programming language or framework

set -e

if [ $# -lt 2 ]; then
    echo "‚ùå Usage: $0 <ModuleName> <feature-name> [location]"
    echo "üìã Examples:"
    echo "   $0 UserService user-authentication"
    echo "   $0 AuthValidator user-authentication core"
    echo "   $0 Logger shared services"
    exit 1
fi

MODULE_NAME=$1
FEATURE_NAME=$2
LOCATION=${3:-"core"}

# Determine the target directory
if [ "$FEATURE_NAME" = "shared" ]; then
    case $LOCATION in
        "core"|"services"|"models"|"utils")
            MODULE_DIR="src/shared/${LOCATION}"
            ;;
        *)
            MODULE_DIR="src/shared/utils"
            ;;
    esac
else
    case $LOCATION in
        "core"|"services"|"models"|"tests")
            MODULE_DIR="src/features/${FEATURE_NAME}/${LOCATION}"
            ;;
        *)
            MODULE_DIR="src/features/${FEATURE_NAME}/core"
            ;;
    esac
fi

echo "üöÄ Creating module: ${MODULE_NAME} in ${FEATURE_NAME}/${LOCATION}"

# Check if feature exists (unless it's shared)
if [ "$FEATURE_NAME" != "shared" ] && [ ! -d "src/features/${FEATURE_NAME}" ]; then
    echo "‚ùå Feature ${FEATURE_NAME} doesn't exist!"
    echo "üí° Create it first with: ./scripts/create-feature ${FEATURE_NAME}"
    exit 1
fi

# Create module directory if it doesn't exist
mkdir -p "$MODULE_DIR"

# Get file extension based on project context
FILE_EXT=""
if [ -f "package.json" ]; then
    # Node.js project - check for TypeScript
    if [ -f "tsconfig.json" ] || grep -q "typescript" package.json 2>/dev/null; then
        FILE_EXT=".ts"
    else
        FILE_EXT=".js"
    fi
elif [ -f "requirements.txt" ] || [ -f "setup.py" ] || [ -f "pyproject.toml" ]; then
    FILE_EXT=".py"
elif [ -f "go.mod" ]; then
    FILE_EXT=".go"
elif [ -f "Cargo.toml" ]; then
    FILE_EXT=".rs"
elif [ -f "pom.xml" ] || [ -f "build.gradle" ]; then
    FILE_EXT=".java"
elif [ -f "*.cs" ] || [ -f "*.csproj" ]; then
    FILE_EXT=".cs"
else
    # Ask user for file extension
    echo "ü§î Could not determine project type. What file extension should I use?"
    echo "Examples: .js, .ts, .py, .go, .rs, .java, .cs, .php, .rb"
    read -p "File extension: " FILE_EXT
    
    if [[ ! "$FILE_EXT" =~ ^\. ]]; then
        FILE_EXT=".$FILE_EXT"
    fi
fi

MODULE_FILE="${MODULE_DIR}/${MODULE_NAME}${FILE_EXT}"
TEST_FILE="${MODULE_DIR}/${MODULE_NAME}.test${FILE_EXT}"

# Check if module already exists
if [ -f "$MODULE_FILE" ]; then
    echo "‚ùå Module ${MODULE_NAME}${FILE_EXT} already exists in ${MODULE_DIR}!"
    exit 1
fi

# Create module documentation file
cat > "${MODULE_DIR}/${MODULE_NAME}.md" << EOF
# ${MODULE_NAME}

## Purpose
Brief description of what this module does and its responsibilities.

## Location
- **Feature**: ${FEATURE_NAME}
- **Directory**: ${LOCATION}
- **File**: ${MODULE_NAME}${FILE_EXT}

## Dependencies
- List any dependencies this module has
- External libraries or services used
- Other modules this depends on

## Usage
\`\`\`
// Add usage examples appropriate for your technology stack
\`\`\`

## API/Interface
Document the public interface:
- Functions/methods exposed
- Parameters and return types
- Error conditions

## Configuration
- Any configuration required
- Environment variables used
- Default values

## Testing
- Test file: ${MODULE_NAME}.test${FILE_EXT}
- Key test scenarios covered
- Mock requirements

## Implementation Notes
- Important implementation decisions
- Performance considerations
- Known limitations or trade-offs

## Related Modules
- List related modules or components
- Dependencies and relationships
EOF

# Create basic module file based on file extension
case $FILE_EXT in
    ".ts"|".js")
        cat > "$MODULE_FILE" << EOF
/**
 * ${MODULE_NAME}
 * 
 * ${FEATURE_NAME} feature - ${LOCATION}
 * 
 * @description Brief description of what this module does
 * @author Generated by Portable Development Methodology
 * @created $(date '+%Y-%m-%d')
 */

export class ${MODULE_NAME} {
  /**
   * Create a new ${MODULE_NAME} instance
   */
  constructor() {
    // Initialize the module
  }

  /**
   * Main functionality - replace with actual implementation
   * @returns Result of the operation
   */
  public execute(): void {
    // Implement main functionality
  }
}

// Export default instance if appropriate
export default ${MODULE_NAME};
EOF
        ;;
    ".py")
        cat > "$MODULE_FILE" << EOF
"""
${MODULE_NAME}

${FEATURE_NAME} feature - ${LOCATION}

This module provides functionality for [brief description].

Author: Generated by Portable Development Methodology
Created: $(date '+%Y-%m-%d')
"""

from typing import Any, Optional


class ${MODULE_NAME}:
    """
    ${MODULE_NAME} class for handling [specific functionality].
    """

    def __init__(self) -> None:
        """Initialize the ${MODULE_NAME}."""
        # Initialize the module
        pass

    def execute(self) -> None:
        """
        Main functionality - replace with actual implementation.
        
        Returns:
            Result of the operation
        """
        # Implement main functionality
        pass


# Create a default instance if appropriate
default_instance = ${MODULE_NAME}()
EOF
        ;;
    ".go")
        PACKAGE_NAME=$(echo "$LOCATION" | tr '[:upper:]' '[:lower:]')
        cat > "$MODULE_FILE" << EOF
// Package $PACKAGE_NAME provides ${LOCATION} functionality for ${FEATURE_NAME}
package $PACKAGE_NAME

import (
    "fmt"
)

// ${MODULE_NAME} represents [brief description]
type ${MODULE_NAME} struct {
    // Add fields as needed
}

// New${MODULE_NAME} creates a new ${MODULE_NAME} instance
func New${MODULE_NAME}() *${MODULE_NAME} {
    return &${MODULE_NAME}{
        // Initialize fields
    }
}

// Execute performs the main functionality
func (m *${MODULE_NAME}) Execute() error {
    // Implement main functionality
    return nil
}
EOF
        ;;
    ".rs")
        cat > "$MODULE_FILE" << EOF
//! ${MODULE_NAME}
//! 
//! ${FEATURE_NAME} feature - ${LOCATION}
//! 
//! This module provides functionality for [brief description].

use std::error::Error;

/// ${MODULE_NAME} struct for handling [specific functionality]
pub struct ${MODULE_NAME} {
    // Add fields as needed
}

impl ${MODULE_NAME} {
    /// Create a new ${MODULE_NAME} instance
    pub fn new() -> Self {
        Self {
            // Initialize fields
        }
    }

    /// Main functionality - replace with actual implementation
    pub fn execute(&self) -> Result<(), Box<dyn Error>> {
        // Implement main functionality
        Ok(())
    }
}

impl Default for ${MODULE_NAME} {
    fn default() -> Self {
        Self::new()
    }
}
EOF
        ;;
    ".java")
        cat > "$MODULE_FILE" << EOF
/**
 * ${MODULE_NAME}
 * 
 * ${FEATURE_NAME} feature - ${LOCATION}
 * 
 * This class provides functionality for [brief description].
 * 
 * @author Generated by Portable Development Methodology
 * @since $(date '+%Y-%m-%d')
 */
public class ${MODULE_NAME} {
    
    /**
     * Create a new ${MODULE_NAME} instance.
     */
    public ${MODULE_NAME}() {
        // Initialize the module
    }
    
    /**
     * Main functionality - replace with actual implementation.
     * 
     * @throws Exception if operation fails
     */
    public void execute() throws Exception {
        // Implement main functionality
    }
}
EOF
        ;;
    *)
        # Generic template for other languages
        cat > "$MODULE_FILE" << EOF
/*
 * ${MODULE_NAME}
 * 
 * ${FEATURE_NAME} feature - ${LOCATION}
 * 
 * This module provides functionality for [brief description].
 * 
 * Author: Generated by Portable Development Methodology
 * Created: $(date '+%Y-%m-%d')
 */

// TODO: Implement ${MODULE_NAME} according to your language's conventions
// This is a generic template - customize for your specific technology stack
EOF
        ;;
esac

echo "üìù Module file created: $MODULE_FILE"

# Create basic test file based on file extension
case $FILE_EXT in
    ".ts"|".js")
        cat > "$TEST_FILE" << EOF
/**
 * Tests for ${MODULE_NAME}
 */

import { ${MODULE_NAME} } from './${MODULE_NAME}';

describe('${MODULE_NAME}', () => {
  let module: ${MODULE_NAME};

  beforeEach(() => {
    module = new ${MODULE_NAME}();
  });

  describe('constructor', () => {
    it('should create an instance', () => {
      expect(module).toBeInstanceOf(${MODULE_NAME});
    });
  });

  describe('execute', () => {
    it('should execute successfully', () => {
      expect(() => module.execute()).not.toThrow();
    });
  });

  // Add more test cases as needed
});
EOF
        ;;
    ".py")
        cat > "$TEST_FILE" << EOF
"""
Tests for ${MODULE_NAME}
"""

import unittest
from .${MODULE_NAME,,} import ${MODULE_NAME}


class Test${MODULE_NAME}(unittest.TestCase):
    """Test cases for ${MODULE_NAME}."""

    def setUp(self) -> None:
        """Set up test fixtures."""
        self.module = ${MODULE_NAME}()

    def test_constructor(self) -> None:
        """Test ${MODULE_NAME} constructor."""
        self.assertIsInstance(self.module, ${MODULE_NAME})

    def test_execute(self) -> None:
        """Test execute method."""
        # Test the main functionality
        self.module.execute()

    # Add more test methods as needed


if __name__ == '__main__':
    unittest.main()
EOF
        ;;
    ".go")
        cat > "$TEST_FILE" << EOF
package $PACKAGE_NAME

import (
    "testing"
)

func Test${MODULE_NAME}_New(t *testing.T) {
    module := New${MODULE_NAME}()
    if module == nil {
        t.Error("New${MODULE_NAME}() returned nil")
    }
}

func Test${MODULE_NAME}_Execute(t *testing.T) {
    module := New${MODULE_NAME}()
    err := module.Execute()
    if err != nil {
        t.Errorf("Execute() returned error: %v", err)
    }
}

// Add more test functions as needed
EOF
        ;;
    ".rs")
        cat > "$TEST_FILE" << EOF
//! Tests for ${MODULE_NAME}

use super::*;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_new() {
        let module = ${MODULE_NAME}::new();
        // Add assertions
    }

    #[test]
    fn test_execute() {
        let module = ${MODULE_NAME}::new();
        let result = module.execute();
        assert!(result.is_ok());
    }

    // Add more test functions as needed
}
EOF
        ;;
    ".java")
        cat > "$TEST_FILE" << EOF
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests for ${MODULE_NAME}
 */
class ${MODULE_NAME}Test {
    
    private ${MODULE_NAME} module;
    
    @BeforeEach
    void setUp() {
        module = new ${MODULE_NAME}();
    }
    
    @Test
    void testConstructor() {
        assertNotNull(module);
    }
    
    @Test
    void testExecute() {
        assertDoesNotThrow(() -> module.execute());
    }
    
    // Add more test methods as needed
}
EOF
        ;;
    *)
        cat > "$TEST_FILE" << EOF
/*
 * Tests for ${MODULE_NAME}
 * 
 * TODO: Implement tests according to your language's testing framework
 * This is a generic template - customize for your specific technology stack
 */

// Add test implementation here
EOF
        ;;
esac

echo "üß™ Test file created: $TEST_FILE"

# Update project memory
echo "üìù Updating project memory..."
DATE=$(date '+%Y-%m-%d %H:%M')
echo "" >> project_memory.md
echo "### ${DATE} - Created ${MODULE_NAME} module" >> project_memory.md
echo "- Added ${MODULE_NAME} to ${FEATURE_NAME}/${LOCATION}" >> project_memory.md
echo "- Created module file with tests and documentation" >> project_memory.md
echo "- File type: ${FILE_EXT}" >> project_memory.md
echo "" >> project_memory.md

echo "‚úÖ Module ${MODULE_NAME} created successfully!"
echo ""
echo "üìÅ Files created:"
echo "   ${MODULE_DIR}/"
echo "   ‚îú‚îÄ‚îÄ ${MODULE_NAME}${FILE_EXT}      # Module implementation"
echo "   ‚îú‚îÄ‚îÄ ${MODULE_NAME}.test${FILE_EXT}  # Unit tests"
echo "   ‚îî‚îÄ‚îÄ ${MODULE_NAME}.md           # Documentation"
echo ""
echo "üéØ Next steps:"
echo "1. Implement the actual functionality in ${MODULE_FILE}"
echo "2. Add comprehensive test cases in ${TEST_FILE}"
echo "3. Update the documentation in ${MODULE_NAME}.md"
echo "4. Consider adding integration tests if needed"
echo "5. Update feature documentation with new module"